# MPU-6050 Sensor with STM32 through I2C
In this project we are going to use I2C (Inter-Integrated Circuit) protocol to obtain the data generated by the sensor MPU-6050. We will use I2C1 in STM32 F446RE in this project. Here are how the pins are connected.
|STM32 F446RE	| MPU-6050 |
|-------------|----------|
|PB8 (SCL)	| SCL |
|PB9 (SDA)	| SDA |
|3V3 | VCC |
|GND | GND |
|ADO | GND |

# Initialization
We are using STM32 as a master who retrieves data from the slave, MPU6050 sensor through I2C. The 7-bit slave address of MPU6050 according to the datasheet is 0x68, however I2C always transmits data in 8-bit (byte) format, so we have to shift it to the left by 1 to configure it with the last bit (0 for write and 1 for read).

We use the function *HAL_I2C_IsDeviceReady()* to check if the slave is ready and output it to UART through ST-Link.
Next, we want to test if the device ID matches the expected output, we need to read *WHO_AM_I* register (0x75) in the sensor to retrieve the sensor ID. It turns out this ID has a sensor ID of 0x70.

If testing is successful, we move on the waking the sensor up. It can be done by flipping bit 6 in *PWR_MGMT_1* register. We can accomplish this by using the *Read-Modify-Write* (RMW), modify is the actual bit masking. After that we read bit 6 again to ensure the sensor is truly awake.
# I2C in DMA mode
We use DMA mode to ensure that the CPU does not need to be involved in the actual transmission of data. To accomplish this, we use the following chain of events:
1.	User button PC13 is pressed.
2.	PC13 sends an interrupt through EXTI line to the NVIC.
3.	CPU informs DMA to start reading the data from the sensor and save it to memory rawData buffer.
4.	When DMA is done reading, it informs the CPU again. The CPU runs HAL_I2C_MemRxCpltCallback function
5.	The CPU copies the data from rawData array to collectionBuffer array.
6.	The CPU flips the readyToCollect flag.
7.	The CPU translates/decodes the message and send it through UART in the main loop.

## Ping-Pong Buffer
Ping-Pong (Shadow) buffer ensures that the fast I2C is not slowed down by the slow UART transmission. I2C writes the buffer to rawData through DMA and the CPU copies the rawData to collectionBuffer using memcpy. This ensures that the collectionBuffer is not slowed down or overwritten by incoming, fast rawData buffer.
# Logic Analyzer
We set the sample rate at 10MHz, and set the negative edge trigger. This is due to the fact that I2C uses open drain design, with the signal defaulting at 3.3V when released.
## Initialization
We begin the initialization by asking the sensor if it is ready, what is its actual sensor ID and wake it up from sleep.

<img width="914" height="219" alt="image1" src="https://github.com/user-attachments/assets/098a3998-9730-45be-aac4-873cfe0852be" />

Figure 1 shows the I2C with a logic analyzer, it is asking whether the sensor is ready.

When *HAL_I2C_IsDeviceReady()* is sent to the sensor, we can see the I2C signal in action using a logic analyzer. The address of the slave is 0x68. Shown by green S, when SCL is high but SDA is pulled low. The mirror event occurs at the end of the signal (shown by Purple P) when the MCU released its SCL line (returns to high because of pull-up resistor); while the SCL is high, the SDA transitions from low to high. The actual frequency of SCL is 344.8kHz.

<img width="1430" height="247" alt="image2" src="https://github.com/user-attachments/assets/71a4fc90-a605-4ac7-bf57-70fa3bcbd3f2" />

Figure 2 shows the I2C signal. The MCU writes and reads the signal to find out the ID value of the sensor.

I2C is always configured to Write first and foremost, it writes to the corresponding address, and restarts and read the value of the desired register. The master (MCU) tells the slave which address it is looking at (0x75) in this case. It turns out to be the *WHO_AM_I* register. The master measures a value of 0x70 from the slave. From the datasheet, the actual value of *WHO_AM_I* should have been 0x68. This tells us that this is not a genuine MPU6050 sensor, and it is very likely to be a clone chip. 

When the master is done reading, we can see that SDA signal remains high during the entire length of SCL signal (around 2358Î¼s). This is a negative acknowledgement signal and tells the master the signal has ended and it can stop the I2C communication. Note that there is a repeated start signal (blue Sr signature) indicating that the I2C allows the writing part to end but allows the master the control of the bus immediately without giving up its turn. 

<img width="1431" height="207" alt="image3" src="https://github.com/user-attachments/assets/73f2d17d-e271-4987-8295-b0c69aa1d618" />

Figure 3 shows the process of *Read-Modify-Write* (RMW) and a final Read to turn on a bit and verifying it.

This is the RMW measured with a logic analyzer. First, the master (CPU) writes to the slave the address 0x6B, which is *PWR_MGMT_1*. The slave replies with a value of 0x01 = 0b00000001. The sixth bit is already 0 (the sensor is already awake). According to the datasheet, it should have been 0b00000010, with the sixth bit being on by default (sensor is asleep for low power mode). This is another indication that MPU6050 is a clone chip. The signal is then written (no change) and read again (unchanged). 

Although this was not the intended method, it is safe because we have not changed any other bits (besides possibly the sixth one). In the clone chip, it is designed to wake up directly instead of staying asleep, this convenience factor is probably why the manufacters altered the design of MPU6050.
## Data Measurement

<img width="1303" height="242" alt="image4" src="https://github.com/user-attachments/assets/d30b3692-3463-461a-b55e-886adf5aa20e" />
<img width="844" height="215" alt="image5" src="https://github.com/user-attachments/assets/def87d2f-95f3-4c1a-969c-09ddc142992d" />

Figure 4 shows the acutal data transmission from MPU6050. This is a 14-byte message containing all the measured values.

Using a logic analyzer, we can see the raw data being sent. As usual, the CPU writes to the slave, and tries to read ACCEL_XOUT_H. This register contains 14 bytes of information, the order are as follows.

1.	Bit 0 & bit 1 : Accelerometer x-axis
2.	Bit 2 & bit 3 : Accelerometer y-axis
3.	Bit 4 & bit 5 : Accelerometer z-axis
4.	Bit 6 & bit 7 : Ambient Temperature
5.	Bit 8 & bit 9 : Gyroscope x-axis
6.	Bit 10 & bit 11 : Gyroscope y-axis
7.	Bit 12 & bit 13 : Gyroscope z-axis

The bits are concatenated together to a 16-bit integer using this formula: ( High Byte << 8 ) | Low Byte. The first bit of high byte is the most significant bit (MSB) while the last bit of the low byte is the least significant bit (LSB). 

Finally, the read data are given in non-usual units (pure integers). A conversion script is provided for direct conversion, using the data read from figure 4, we get a physical unit of

<img width="658" height="320" alt="image6" src="https://github.com/user-attachments/assets/15243cd5-9db1-4487-89a5-597d8528b195" />

Figure 5 shows the raw data being translated into physical units. Notice that z-axis is reading a value of 0.96g, the local gravity acceleration.
